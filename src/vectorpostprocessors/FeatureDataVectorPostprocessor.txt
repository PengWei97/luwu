//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "FeatureDataVectorPostprocessor.h"

registerMooseObject("luwuApp", FeatureDataVectorPostprocessor);

InputParameters
FeatureDataVectorPostprocessor::validParams()
{
  InputParameters params = FeatureVolumeVectorPostprocessor::validParams();
  params.addClassDescription("This object is designed to pull information from the data structures "
                             "of a \"FeatureFloodCount\" or derived object (e.g. individual "
                             "feature volumes)");
  return params;
}

FeatureDataVectorPostprocessor::FeatureDataVectorPostprocessor(
    const InputParameters & parameters)
  : FeatureVolumeVectorPostprocessor(parameters),
    _feature_id(declareVector("feature_id")),
    _adjacent_num(declareVector("adjacent_num"))
{
}

void
FeatureDataVectorPostprocessor::initialize()
{
}

void
FeatureDataVectorPostprocessor::execute()
{
  // FeatureVolumeVectorPostprocessor::execute();
  
  // const auto num_features = _feature_counter.getTotalFeatureCount();

  // // Reset the variable index and intersect bounds vectors
  // _feature_id.assign(num_features, -1);  // add
  // _adjacent_num.assign(num_features, 0); // add
  // // _var_num.assign(num_features, -1);

  // for (MooseIndex(num_features) feature_num = 0; feature_num < num_features; ++feature_num)
  // {
  //   auto feature_id = _feature_counter.getFeatureID(feature_num);
  //   auto adjacent_num = _feature_counter.getAdjacentGrainNum(feature_num);
  //   auto var_num = _feature_counter.getFeatureVar(feature_num);

  //   if (var_num != FeatureFloodCount::invalid_id)
  //   {
  //     _feature_id[feature_num] = feature_num;
  //     // _var_num[feature_num] = var_num;
  //     _adjacent_num[feature_num] = adjacent_num;
  //   }
      
  const auto num_features = _feature_counter.getTotalFeatureCount();

  // Reset the variable index and intersect bounds vectors
  _var_num.assign(num_features, -1);                     // Invalid
  _intersects_bounds.assign(num_features, -1);           // Invalid
  _intersects_specified_bounds.assign(num_features, -1); // Invalid
  _percolated.assign(num_features, -1);                  // Invalid
  for (MooseIndex(num_features) feature_num = 0; feature_num < num_features; ++feature_num)
  {
    auto var_num = _feature_counter.getFeatureVar(feature_num);
    if (var_num != FeatureFloodCount::invalid_id)
      _var_num[feature_num] = var_num;

    _intersects_bounds[feature_num] =
        static_cast<unsigned int>(_feature_counter.doesFeatureIntersectBoundary(feature_num));

    _intersects_specified_bounds[feature_num] = static_cast<unsigned int>(
        _feature_counter.doesFeatureIntersectSpecifiedBoundary(feature_num));

    _percolated[feature_num] =
        static_cast<unsigned int>(_feature_counter.isFeaturePercolated(feature_num));
  }

  if (_output_centroids)
  {
    for (std::size_t i = 0; i < 3; ++i)
      _centroid[i]->resize(num_features);
    for (std::size_t feature_num = 0; feature_num < num_features; ++feature_num)
    {
      auto p = _feature_counter.featureCentroid(feature_num);
      for (std::size_t i = 0; i < 3; ++i)
        (*_centroid[i])[feature_num] = p(i);
    }
  }

  // Reset the volume vector
  _feature_volumes.assign(num_features, 0);

  // Calculate coverage of a boundary if one has been supplied in the input file
  if (_is_boundary_restricted)
  {
    const std::set<BoundaryID> supplied_bnd_ids = BoundaryRestrictable::boundaryIDs();
    for (auto elem_it = _mesh.bndElemsBegin(), elem_end = _mesh.bndElemsEnd(); elem_it != elem_end;
         ++elem_it)

      // loop over only boundaries supplied by user in boundary param
      for (auto & supplied_bnd_id : supplied_bnd_ids)
        if (((*elem_it)->_bnd_id) == supplied_bnd_id)
        {
          const auto & elem = (*elem_it)->_elem;
          auto rank = processor_id();

          if (elem->processor_id() == rank)
          {
            _fe_problem.setCurrentSubdomainID(elem, 0);
            _fe_problem.prepare(elem, 0);
            _fe_problem.reinitElem(elem, 0);
            _fe_problem.reinitElemFace(elem, (*elem_it)->_side, (*elem_it)->_bnd_id, 0);

            const auto & var_to_features = _feature_counter.getVarToFeatureVector(elem->id());

            accumulateBoundaryFaces(elem, var_to_features, num_features, (*elem_it)->_side);
          }
        }
  }
  else // If no boundary is supplied, calculate volumes of features as normal
    for (const auto & elem : _mesh.getMesh().active_local_element_ptr_range())
    {
      _fe_problem.setCurrentSubdomainID(elem, 0);
      _fe_problem.prepare(elem, 0);
      _fe_problem.reinitElem(elem, 0);

      /**
       * Here we retrieve the var to features vector on the current element.
       * We'll use that information to figure out which variables are non-zero
       * (from a threshold perspective) then we can sum those values into
       * appropriate grain index locations.
       */
      const auto & var_to_features = _feature_counter.getVarToFeatureVector(elem->id());

      accumulateVolumes(elem, var_to_features, num_features);
    }
}

void
FeatureDataVectorPostprocessor::finalize()
{
  FeatureVolumeVectorPostprocessor::finalize();
}